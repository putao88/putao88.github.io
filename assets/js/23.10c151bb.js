(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{384:function(t,e,r){"use strict";r.r(e);var l=r(25),a=Object(l.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"参考文章"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[t._v("#")]),t._v(" 参考文章")]),t._v(" "),r("p",[r("a",{attrs:{href:"https://www.electronjs.org/zh/docs/latest",target:"_blank",rel:"noopener noreferrer"}},[t._v("官网"),r("OutboundLink")],1)]),t._v(" "),r("h2",{attrs:{id:"基础概念"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#基础概念"}},[t._v("#")]),t._v(" 基础概念")]),t._v(" "),r("h3",{attrs:{id:"electron主要组成"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#electron主要组成"}},[t._v("#")]),t._v(" Electron主要组成")]),t._v(" "),r("ul",[r("li",[t._v("main.js: 主进程")]),t._v(" "),r("li",[t._v("preload.js: 预加载")]),t._v(" "),r("li",[t._v("index.html: html显示")]),t._v(" "),r("li",[t._v("render.js : 渲染进程")]),t._v(" "),r("li",[t._v("out: 打包文件")])]),t._v(" "),r("h3",{attrs:{id:"打包应用程序"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#打包应用程序"}},[t._v("#")]),t._v(" 打包应用程序")]),t._v(" "),r("ul",[r("li",[t._v("Electron Forge是electron打包构建工具,可以打包应用程序")]),t._v(" "),r("li",[t._v("out文件夹是打包后的输出")]),t._v(" "),r("li",[r("a",{attrs:{href:"https://www.electronjs.org/zh/docs/latest/tutorial/code-signing",target:"_blank",rel:"noopener noreferrer"}},[t._v("code signing"),r("OutboundLink")],1),t._v(": 代码签名,为了使应用程序为已知源,mac和windows不允许用户下载未知源的应用(为了让您的应用程序受到用户系统的信任，您需要通过对其进行代码签名，以数字方式证明可分发的应用程序是可信的且未受到干扰。)")])]),t._v(" "),r("h3",{attrs:{id:"发布和更新"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#发布和更新"}},[t._v("#")]),t._v(" 发布和更新")]),t._v(" "),r("ul",[r("li",[t._v("创建一个github库,制定一个版本自动发布更新你的代码到应用程序")]),t._v(" "),r("li",[t._v("Using update.electronjs.org : 提供一个自动更新的程序,github版本已更新,它就自动为你的应用更新")])]),t._v(" "),r("h3",{attrs:{id:"electron进程间通信"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#electron进程间通信"}},[t._v("#")]),t._v(" Electron进程间通信")]),t._v(" "),r("ul",[r("li",[t._v("模式 1：渲染器进程到主进程（单向）\n要将单向 IPC 消息从渲染器进程发送到主进程，您可以使用 ipcRenderer.send API 发送消息，然后使用 ipcMain.on API 接收。通常使用此模式从 Web 内容调用主进程 API\n"),r("ul",[r("li",[r("ol",[r("li",[t._v("使用 ipcMain.on 监听事件")])])]),t._v(" "),r("li",[r("ol",{attrs:{start:"2"}},[r("li",[t._v("通过预加载脚本暴露 ipcRenderer.send")])])]),t._v(" "),r("li",[r("ol",{attrs:{start:"3"}},[r("li",[t._v("构建渲染器进程 UI")])])])])]),t._v(" "),r("li",[t._v("模式 2：渲染器进程到主进程（双向）\n双向 IPC 的一个常见应用是从渲染器进程代码调用主进程模块并等待结果。 这可以通过将 ipcRenderer.invoke 与 ipcMain.handle 搭配使用来完成\n"),r("ul",[r("li",[r("ol",[r("li",[t._v("使用 ipcMain.handle 监听事件")])])]),t._v(" "),r("li",[r("ol",{attrs:{start:"2"}},[r("li",[t._v("通过预加载脚本暴露 ipcRenderer.invoke")])])]),t._v(" "),r("li",[r("ol",{attrs:{start:"3"}},[r("li",[t._v("构建渲染器进程 UI")])])])])]),t._v(" "),r("li",[t._v("模式 3：主进程到渲染器进程\n"),r("ul",[r("li",[r("ol",[r("li",[t._v("使用 webContents 模块发送消息")])])]),t._v(" "),r("li",[r("ol",{attrs:{start:"2"}},[r("li",[t._v("通过预加载脚本暴露 ipcRenderer.on")])])]),t._v(" "),r("li",[r("ol",{attrs:{start:"3"}},[r("li",[t._v("构建渲染器进程 UI")])])])])]),t._v(" "),r("li",[t._v("模式 4：渲染器进程到渲染器进程")])])])}),[],!1,null,null,null);e.default=a.exports}}]);