(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{389:function(t,e,a){"use strict";a.r(e);var r=a(25),n=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"参考资料"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://juejin.cn/post/6981588276356317214",target:"_blank",rel:"noopener noreferrer"}},[t._v("垃圾回收机制"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://juejin.cn/post/6844904016325902344",target:"_blank",rel:"noopener noreferrer"}},[t._v("一文搞懂V8引擎的垃圾回收"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://juejin.cn/post/6909239354418266119",target:"_blank",rel:"noopener noreferrer"}},[t._v("V8 引擎垃圾回收与内存分配"),a("OutboundLink")],1)])]),t._v(" "),a("h2",{attrs:{id:"v8引擎垃圾回收机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#v8引擎垃圾回收机制"}},[t._v("#")]),t._v(" V8引擎垃圾回收机制")]),t._v(" "),a("h3",{attrs:{id:"为什么需要垃圾回收"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要垃圾回收"}},[t._v("#")]),t._v(" 为什么需要垃圾回收")]),t._v(" "),a("ul",[a("li",[t._v("在V8引擎逐行执行JavaScript代码的过程中，当遇到函数的情况时，会为其创建一个函数执行上下文(Context)环境并添加到调用堆栈的栈顶，函数的作用域(handleScope)中包含了该函数中声明的所有变量，当该函数执行完毕后，对应的执行上下文从栈顶弹出，函数的作用域会随之销毁，其包含的所有变量也会统一释放并被自动回收。试想如果在这个作用域被销毁的过程中，其中的变量不被回收，即持久占用内存，那么必然会导致内存暴增，从而引发内存泄漏导致程序的性能直线下降甚至崩溃，因此内存在使用完毕之后理当归还给操作系统以保证内存的重复利用。")])]),t._v(" "),a("h3",{attrs:{id:"垃圾回收策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收策略"}},[t._v("#")]),t._v(" 垃圾回收策略")]),t._v(" "),a("p",[t._v("V8的垃圾回收策略主要是基于分代式垃圾回收机制，其根据对象的存活时间将内存的垃圾回收进行不同的分代，然后对不同的分代采用不同的垃圾回收算法。")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("新生代")]),t._v(":内存最大值在64位系统和32位系统上分别为32MB和16MB，在新生代的垃圾回收过程中主要采用了Scavenge算法\n"),a("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/817b06be81fa4936b96e0df7395aa76b~tplv-k3u1fbpfcp-watermark.awebp",alt:"Scavenge算法翻转空间"}})]),t._v(" "),a("li",[a("strong",[t._v("对象晋升")]),t._v(":当一个对象在经过多次复制之后依旧存活，那么它会被认为是一个生命周期较长的对象，在下一次进行垃圾回收时，该对象会被直接转移到老生代中;\n对象晋升的条件主要有以下两个：\n"),a("ol",[a("li",[t._v("对象是否经历过一次Scavenge算法")]),t._v(" "),a("li",[t._v("To空间的内存占比是否已经超过25%")])])]),t._v(" "),a("li",[a("strong",[t._v("老生代")]),t._v(":采用新的算法Mark-Sweep(标记清除)和Mark-Compact(标记整理)来进行管理\n"),a("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a21ebc14ef64bfc9e3d3d803bcb488c~tplv-k3u1fbpfcp-watermark.awebp",alt:"内存管理策略"}})])]),t._v(" "),a("h3",{attrs:{id:"如何避免内存泄漏"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何避免内存泄漏"}},[t._v("#")]),t._v(" 如何避免内存泄漏")]),t._v(" "),a("ul",[a("li",[t._v("尽可能少地创建全局变量")]),t._v(" "),a("li",[t._v("手动清除定时器")]),t._v(" "),a("li",[t._v("少用闭包")]),t._v(" "),a("li",[t._v("清除DOM引用")]),t._v(" "),a("li",[t._v("弱引用")])])])}),[],!1,null,null,null);e.default=n.exports}}]);