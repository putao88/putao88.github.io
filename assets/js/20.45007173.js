(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{381:function(a,t,s){"use strict";s.r(t);var e=s(45),r=Object(e.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h2",{attrs:{id:"认识vue"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#认识vue"}},[a._v("#")]),a._v(" 认识Vue")]),a._v(" "),s("h3",{attrs:{id:"_1-vue是一个渐进式框架-什么是渐进式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-vue是一个渐进式框架-什么是渐进式"}},[a._v("#")]),a._v(" 1.Vue是一个渐进式框架，什么是渐进式？")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("渐进式意味着你可以将Vue作为你应用的一部分嵌入其中，带来更丰富的体验\n或者如果你希望将更多的业务逻辑使用Vue实现，那么Vue的核心库以及其生态系统\n比如Core+Vue-router+Vuex，也许可以满足你各式各样的需求\n")])])]),s("h3",{attrs:{id:"_2-vue有很多特点和web开发中常见的高级功能"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-vue有很多特点和web开发中常见的高级功能"}},[a._v("#")]),a._v(" 2.Vue有很多特点和Web开发中常见的高级功能")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("解耦视图和数据\n可复用的组件\n前端路由技术\n状态管理\n虚拟DOM\n")])])]),s("h2",{attrs:{id:"vue-js安装"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue-js安装"}},[a._v("#")]),a._v(" Vue.js安装")]),a._v(" "),s("h3",{attrs:{id:"安装vue的方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#安装vue的方式"}},[a._v("#")]),a._v(" 安装Vue的方式：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("方式一：直接CDN引入\n    1.开发版本：有报错命令行警告，可查看源码\n    2.生产版本：生产上线使用，优化了尺寸和速度\n方式二：下载和引入\n方式三：NPM安装\n")])])]),s("h2",{attrs:{id:"体验vue的响应式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#体验vue的响应式"}},[a._v("#")]),a._v(" 体验Vue的响应式")]),a._v(" "),s("h3",{attrs:{id:"代码做了什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#代码做了什么"}},[a._v("#")]),a._v(" 代码做了什么")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("创建了一个Vue对象\n创建对象时，掺入了一些options:{}\n    {}中包含了el属性：该属性决定了这个Vue对象挂载到哪一个元素\n    {}中包含了data属性，该属性中通常会存储一些数据\n浏览器执行代码\n")])])]),s("h3",{attrs:{id:"vue列表显示"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue列表显示"}},[a._v("#")]),a._v(" Vue列表显示")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("使用v-for指令\n")])])]),s("h3",{attrs:{id:"计数器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#计数器"}},[a._v("#")]),a._v(" 计数器")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("新的属性：methods\n语法糖：简写\n")])])]),s("h2",{attrs:{id:"vue中的mvvm"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue中的mvvm"}},[a._v("#")]),a._v(" Vue中的MVVM")]),a._v(" "),s("h3",{attrs:{id:"什么是mvvm"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是mvvm"}},[a._v("#")]),a._v(" 什么是MVVM")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("Model  ViewModel View\n")])])]),s("h3",{attrs:{id:"vue中的mvvm-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue中的mvvm-2"}},[a._v("#")]),a._v(" Vue中的MVVM")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("绑定数据\n监听DOM\n")])])]),s("h2",{attrs:{id:"创建vue实例时传入的options"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#创建vue实例时传入的options"}},[a._v("#")]),a._v(" 创建Vue实例时传入的options")]),a._v(" "),s("p",[a._v("包含的选项：\n1.el:决定之后vue实例会管理哪一个DOM\n2.data:vue实例对应的数据对象\n3.methods：定义属于Vue的一些方法，可以在其他地方调用，也可以在指令中使用")]),a._v(" "),s("h3",{attrs:{id:"开发中什么时候称之为方法-什么时候称为函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#开发中什么时候称之为方法-什么时候称为函数"}},[a._v("#")]),a._v(" 开发中什么时候称之为方法，什么时候称为函数")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("methods：方法，一般包含在类中；\nfunction：函数，单独定义\n")])])]),s("h2",{attrs:{id:"vue的生命周期"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue的生命周期"}},[a._v("#")]),a._v(" Vue的生命周期")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("一般代码缩进2个空格更符合规范\n")])])]),s("h2",{attrs:{id:"vue模版语法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue模版语法"}},[a._v("#")]),a._v(" Vue模版语法")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("1.Mustache：其实就是双大括号\n2.v-once：只第一次渲染\n3.v-html: 渲染html\n4.v-text: 和Mustache很相似\n5.v-pre: v-pre用于跳过这个元素和他子元素的编译过程\n6.v-cloak：斗篷,通常和disaplay:none结合使用，用于首频加载显示问题\n7.v-bind：动态绑定属性\n    v-bind绑定style\n")])])]),s("h3",{attrs:{id:"计算属性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#计算属性"}},[a._v("#")]),a._v(" 计算属性")]),a._v(" "),s("h4",{attrs:{id:"计算属性的setter和getter"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#计算属性的setter和getter"}},[a._v("#")]),a._v(" 计算属性的setter和getter")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("每一个计算属性都包含一个getter和一个setter\n计算属性一般是没有set方法，只读属性\n")])])]),s("h4",{attrs:{id:"计算属性和methods的对比"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#计算属性和methods的对比"}},[a._v("#")]),a._v(" 计算属性和methods的对比")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("计算属性会进行缓存，如果多次使用时，计算属性只会调用一次\n")])])]),s("h3",{attrs:{id:"es6"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es6"}},[a._v("#")]),a._v(" ES6")]),a._v(" "),s("h4",{attrs:{id:"let和const"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#let和const"}},[a._v("#")]),a._v(" let和const")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("事实上var是JavaScript语言设计上的错误，但是这种错误多半不能修复和移除，以为需要向后兼容\n1.变量作用域：变量在什么范围内是可用的\n2.没有块级作用域引起的问题\n    if的块级\n    for的块级\nvar没有块级作用域，\n3.建议在ES6开发中，优先用const,\n")])])]),s("h4",{attrs:{id:"const"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#const"}},[a._v("#")]),a._v(" const")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("1.  一旦给const修饰的标识符被赋值之后，不能修改\n2.在使用const定义标识符，必须进行赋值\n3.常量的含义是指向的对象不能修改，但是可以改变对象内部的属性\n")])])]),s("h4",{attrs:{id:"对象字面量增强写法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#对象字面量增强写法"}},[a._v("#")]),a._v(" 对象字面量增强写法")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("angularjs(google)\nTypeScript(Microsoft)->ts\nflow(facebook)\n")])])]),s("h3",{attrs:{id:"事件监听"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#事件监听"}},[a._v("#")]),a._v(" 事件监听")]),a._v(" "),s("h4",{attrs:{id:"v-on参数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v-on参数"}},[a._v("#")]),a._v(" v-on参数")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("情况一：如果该方法不需要额外参数，那么方法后的（）可以不添加\n    但是注意：如果方法本身有一个参数，那么会默认将原生事件event参数传递进去\n情况二：如果需要同时传入某个参数，同时需要event时，可以通过$event传入事件\n")])])]),s("h4",{attrs:{id:"v-on修饰符"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v-on修饰符"}},[a._v("#")]),a._v(" v-on修饰符")]),a._v(" "),s("h3",{attrs:{id:"循环遍历"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#循环遍历"}},[a._v("#")]),a._v(" 循环遍历")]),a._v(" "),s("h4",{attrs:{id:"数组响应式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数组响应式"}},[a._v("#")]),a._v(" 数组响应式")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("1.push方法\n2.pop():删除数组中的最后一个元素\n3.shift():删除数组中的第一个元素\n4.unshift():在数组最前面添加元素\n5.slice():删除元素/插入元素/替换元素\n6.sort():数组排序\n7.reverse()\n8.注意：通过索引值修改数组中的元素\nVue内置的通过索引修改数组值的方式：set(要修改的对象，索引值，修改后的值)\n")])])]),s("h3",{attrs:{id:"v-model的基本使用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v-model的基本使用"}},[a._v("#")]),a._v(" v-model的基本使用")]),a._v(" "),s("h4",{attrs:{id:"v-model实现双向绑定的原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v-model实现双向绑定的原理"}},[a._v("#")]),a._v(" v-model实现双向绑定的原理")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("v-model其实是一个语法糖，他的背后本质上是包含两个操作：\n    1.v-bind绑定一个value属性\n    2.v-on指令给当前元素绑定input事件\n")])])]),s("h4",{attrs:{id:"v-model修饰符的使用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v-model修饰符的使用"}},[a._v("#")]),a._v(" v-model修饰符的使用")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("1.lazy:v-model 在每次 input 事件触发后将输入框的值与数据进行同步 (除了上述输入法组合文字时)。你可以添加 lazy 修饰符，从而转为在 change 事件_之后_进行同步\n2.number:如果想自动将用户的输入值转为数值类型，可以给 v-model 添加 number 修饰符\n3.trim:如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符\n")])])]),s("h3",{attrs:{id:"组件化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#组件化"}},[a._v("#")]),a._v(" 组件化")]),a._v(" "),s("h3",{attrs:{id:"组件化开发"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#组件化开发"}},[a._v("#")]),a._v(" 组件化开发")]),a._v(" "),s("h4",{attrs:{id:"父组件访问自组件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#父组件访问自组件"}},[a._v("#")]),a._v(" 父组件访问自组件")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("1.$children:一般需要拿到所有子组件时使用\n2.$refs：对象类型，默认是一个空对象，大部分情况都使用这种方式获取子组件\n")])])]),s("h4",{attrs:{id:"子组件访问父组件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#子组件访问父组件"}},[a._v("#")]),a._v(" 子组件访问父组件")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("1.$paraent：复用性不强，耦合度太高\n2.$root：访问根组件\n")])])]),s("h3",{attrs:{id:"可复用性-组合"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#可复用性-组合"}},[a._v("#")]),a._v(" 可复用性 & 组合")]),a._v(" "),s("h4",{attrs:{id:"自定义指令"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#自定义指令"}},[a._v("#")]),a._v(" 自定义指令")]),a._v(" "),s("h4",{attrs:{id:"渲染函数-jsx"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#渲染函数-jsx"}},[a._v("#")]),a._v(" 渲染函数 & JSX")])])}),[],!1,null,null,null);t.default=r.exports}}]);