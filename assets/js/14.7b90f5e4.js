(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{375:function(t,s,r){"use strict";r.r(s);var a=r(25),_=Object(a.a)({},(function(){var t=this,s=t.$createElement,r=t._self._c||s;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"_1-面向对象编程介绍"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-面向对象编程介绍"}},[t._v("#")]),t._v(" 1.面向对象编程介绍")]),t._v(" "),r("h3",{attrs:{id:"_1-3-面向对象编程oop-object-oriented-programming"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-面向对象编程oop-object-oriented-programming"}},[t._v("#")]),t._v(" 1.3 面向对象编程OOP(Object Oriented Programming)")]),t._v(" "),r("ol",[r("li",[t._v("面向对象是把事物分解成一个个对象，然后由对象之间分工与合作")]),t._v(" "),r("li",[t._v("面向对象具有灵活，代码可复用，容易维护和开发的优点，更适合多人合作的大型软件项目")]),t._v(" "),r("li",[t._v("面向对象的特性：封装性，继承性，多态性")])]),t._v(" "),r("h3",{attrs:{id:"_1-4-面向过程和面向对象的对比"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-面向过程和面向对象的对比"}},[t._v("#")]),t._v(" 1.4 面向过程和面向对象的对比")]),t._v(" "),r("h4",{attrs:{id:"面向过程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#面向过程"}},[t._v("#")]),t._v(" 面向过程")]),t._v(" "),r("blockquote",[r("p",[t._v("优点：性能比面向对象高，适合跟硬件联系很紧密的东西，例如单片机就采用的面向过程编程\n缺点：没有面向对象易维护，易复用，易扩展")])]),t._v(" "),r("h4",{attrs:{id:"面向对象"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#面向对象"}},[t._v("#")]),t._v(" 面向对象")]),t._v(" "),r("blockquote",[r("p",[t._v("优点：易维护，易复用，易扩展，由于面向对象有封装，继承，多态的特性，可以设计出低耦合的系统，使系统更加灵活，更加易于维护\n缺点：性能比面向过程低")])]),t._v(" "),r("h2",{attrs:{id:"_2-es6中的类和对象"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-es6中的类和对象"}},[t._v("#")]),t._v(" 2.ES6中的类和对象")]),t._v(" "),r("p",[r("strong",[t._v("面向对象的思维特点")]),t._v("：")]),t._v(" "),r("ol",[r("li",[t._v("抽取（抽象）对象共用的属性和行为组织（封装）成一个类（模版）")]),t._v(" "),r("li",[t._v("对类进行实例化，获取类的对象")])]),t._v(" "),r("h3",{attrs:{id:"_2-1-对象"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-对象"}},[t._v("#")]),t._v(" 2.1 对象")]),t._v(" "),r("p",[r("strong",[t._v("对象是由属性和方法组成的")]),t._v("：\n属性：事物的特征，在对象中用属性来表示\n方法：事物的行为，在对象中用方法来表示")]),t._v(" "),r("h3",{attrs:{id:"_2-3-类-class"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-类-class"}},[t._v("#")]),t._v(" 2.3 类 class")]),t._v(" "),r("p",[t._v("在ES6中新增加了类的概念，可以使用class关键字声明一个类，之后以这个类来实例化对象\n类抽象了对象的公共部分，它泛指某一大类（class）\n对象特指某一个，通过实例化一个具体的对象")]),t._v(" "),r("h3",{attrs:{id:"_2-4-类constructor构造函数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-类constructor构造函数"}},[t._v("#")]),t._v(" 2.4  类constructor构造函数")]),t._v(" "),r("p",[t._v("constructor()方法是类的构造函数（默认方法），用于传递参数，返回实例对象，通过new命令生成对象实例时，自动调用该方法，如果没有显示定义，类内部会自动给我们创建一个constructor")]),t._v(" "),r("p",[r("strong",[t._v("注意")])]),t._v(" "),r("ol",[r("li",[t._v("通过class关键字创建类，类名我们还是习惯性定义首字母大写")]),t._v(" "),r("li",[t._v("类里面有个constructor函数，可以接受传递过来的参数，同时返回实例对象")]),t._v(" "),r("li",[t._v("constructor函数只要new生成实例时，就会自动调用这个函数，如果我们不写这个函数，类也会自动生成这个函数")]),t._v(" "),r("li",[t._v("生成实例new不能省略")]),t._v(" "),r("li",[t._v("最后注意语法规范，创建类，类名后面不要加小括号，生成实例类名后面要加小括号，构造函数不需要加function")])]),t._v(" "),r("h2",{attrs:{id:"_3-类的继承"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-类的继承"}},[t._v("#")]),t._v(" 3.类的继承")]),t._v(" "),r("h3",{attrs:{id:"_3-1-继承-extends"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-继承-extends"}},[t._v("#")]),t._v(" 3.1 继承 extends")]),t._v(" "),r("p",[t._v("子类可以继承父类的一些属性和方法")]),t._v(" "),r("h3",{attrs:{id:"_3-2-super关键字"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-super关键字"}},[t._v("#")]),t._v(" 3.2 super关键字")]),t._v(" "),r("p",[t._v("super关键字用于访问和调用对象父类上的函数。可以调用父类的构造函数，也可以调用父类的普通函数")]),t._v(" "),r("blockquote",[r("p",[t._v("super必须在子类this之前调用\n"),r("strong",[t._v("继承中的属性或者方法原则：就近原则")])])])])}),[],!1,null,null,null);s.default=_.exports}}]);