<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>参考资料 | 葡萄的文档</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/favicon.ico">
    <meta name="description" content="用于记录日常积累技术知识">
    
    <link rel="preload" href="/assets/css/0.styles.280e3266.css" as="style"><link rel="preload" href="/assets/js/app.6f4b980a.js" as="script"><link rel="preload" href="/assets/js/2.1c181746.js" as="script"><link rel="preload" href="/assets/js/18.09872d34.js" as="script"><link rel="prefetch" href="/assets/js/10.179df2aa.js"><link rel="prefetch" href="/assets/js/11.85fe1297.js"><link rel="prefetch" href="/assets/js/12.048de200.js"><link rel="prefetch" href="/assets/js/13.f7b5f9d6.js"><link rel="prefetch" href="/assets/js/14.5883df6e.js"><link rel="prefetch" href="/assets/js/15.cb0d67d8.js"><link rel="prefetch" href="/assets/js/16.456564a9.js"><link rel="prefetch" href="/assets/js/17.11fe2341.js"><link rel="prefetch" href="/assets/js/19.c7391902.js"><link rel="prefetch" href="/assets/js/20.4adb293b.js"><link rel="prefetch" href="/assets/js/21.cbf9fc3c.js"><link rel="prefetch" href="/assets/js/22.e9346db5.js"><link rel="prefetch" href="/assets/js/23.42d6ba45.js"><link rel="prefetch" href="/assets/js/24.4fef39db.js"><link rel="prefetch" href="/assets/js/25.21e65698.js"><link rel="prefetch" href="/assets/js/26.79b3986e.js"><link rel="prefetch" href="/assets/js/27.ebf2d4a2.js"><link rel="prefetch" href="/assets/js/28.fb643af8.js"><link rel="prefetch" href="/assets/js/29.70130f48.js"><link rel="prefetch" href="/assets/js/3.f4477480.js"><link rel="prefetch" href="/assets/js/30.a6d022d5.js"><link rel="prefetch" href="/assets/js/31.aa03a0b4.js"><link rel="prefetch" href="/assets/js/32.25bb32a8.js"><link rel="prefetch" href="/assets/js/33.f9a2c192.js"><link rel="prefetch" href="/assets/js/34.f329f873.js"><link rel="prefetch" href="/assets/js/35.67c74567.js"><link rel="prefetch" href="/assets/js/36.8a54ea55.js"><link rel="prefetch" href="/assets/js/37.0d74c9a5.js"><link rel="prefetch" href="/assets/js/38.7e1eaf23.js"><link rel="prefetch" href="/assets/js/39.2f240d25.js"><link rel="prefetch" href="/assets/js/4.2a91c552.js"><link rel="prefetch" href="/assets/js/40.4330b1e1.js"><link rel="prefetch" href="/assets/js/41.fda4121b.js"><link rel="prefetch" href="/assets/js/42.c1e56ba0.js"><link rel="prefetch" href="/assets/js/43.df357b6f.js"><link rel="prefetch" href="/assets/js/44.a737047e.js"><link rel="prefetch" href="/assets/js/45.b033a434.js"><link rel="prefetch" href="/assets/js/46.0d8d1173.js"><link rel="prefetch" href="/assets/js/47.e220ae86.js"><link rel="prefetch" href="/assets/js/48.84469ded.js"><link rel="prefetch" href="/assets/js/49.0b588f0a.js"><link rel="prefetch" href="/assets/js/5.3f5e3f15.js"><link rel="prefetch" href="/assets/js/50.6d28fdb9.js"><link rel="prefetch" href="/assets/js/51.be3a58ae.js"><link rel="prefetch" href="/assets/js/52.d8e08e0e.js"><link rel="prefetch" href="/assets/js/53.9d70cec6.js"><link rel="prefetch" href="/assets/js/54.7a79ecf2.js"><link rel="prefetch" href="/assets/js/55.55dcf0a0.js"><link rel="prefetch" href="/assets/js/56.ef384414.js"><link rel="prefetch" href="/assets/js/57.7cfb823b.js"><link rel="prefetch" href="/assets/js/58.cc7cb9a6.js"><link rel="prefetch" href="/assets/js/59.8594cbc3.js"><link rel="prefetch" href="/assets/js/6.8b11760f.js"><link rel="prefetch" href="/assets/js/60.c8657cc8.js"><link rel="prefetch" href="/assets/js/61.35c95e9f.js"><link rel="prefetch" href="/assets/js/62.32404d1c.js"><link rel="prefetch" href="/assets/js/63.e68cb184.js"><link rel="prefetch" href="/assets/js/64.f80095f8.js"><link rel="prefetch" href="/assets/js/65.b59306ab.js"><link rel="prefetch" href="/assets/js/66.c68485e6.js"><link rel="prefetch" href="/assets/js/67.b224d1cb.js"><link rel="prefetch" href="/assets/js/68.048b3ad8.js"><link rel="prefetch" href="/assets/js/69.1d8f497f.js"><link rel="prefetch" href="/assets/js/7.bf4e53c2.js"><link rel="prefetch" href="/assets/js/70.1b618d20.js"><link rel="prefetch" href="/assets/js/71.86488051.js"><link rel="prefetch" href="/assets/js/72.2666ed67.js"><link rel="prefetch" href="/assets/js/73.6418ab00.js"><link rel="prefetch" href="/assets/js/74.c2e8fb1c.js"><link rel="prefetch" href="/assets/js/75.c9753863.js"><link rel="prefetch" href="/assets/js/76.5bc71094.js"><link rel="prefetch" href="/assets/js/77.c64654bc.js"><link rel="prefetch" href="/assets/js/78.50cbd33d.js"><link rel="prefetch" href="/assets/js/79.0b34f8ab.js"><link rel="prefetch" href="/assets/js/8.df64f410.js"><link rel="prefetch" href="/assets/js/80.c28e9eb0.js"><link rel="prefetch" href="/assets/js/81.1b0b646a.js"><link rel="prefetch" href="/assets/js/82.95e3c2b5.js"><link rel="prefetch" href="/assets/js/9.87c58f8b.js">
    <link rel="stylesheet" href="/assets/css/0.styles.280e3266.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">葡萄的文档</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/Study/前端学习路线/概览.html" class="nav-link">
  Study
</a></div><div class="nav-item"><a href="/Chrome/Devtools/概览.html" class="nav-link">
  Chrome
</a></div><div class="nav-item"><a href="/面试/前端面试准备/概览.html" class="nav-link">
  面试
</a></div><div class="nav-item"><a href="https://putao88.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/putao88/Document" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/Study/前端学习路线/概览.html" class="nav-link">
  Study
</a></div><div class="nav-item"><a href="/Chrome/Devtools/概览.html" class="nav-link">
  Chrome
</a></div><div class="nav-item"><a href="/面试/前端面试准备/概览.html" class="nav-link">
  面试
</a></div><div class="nav-item"><a href="https://putao88.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/putao88/Document" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端学习路线</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>资源分享</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>常用知识点总结</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>CSS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JavaScript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>ES6</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Study/ES6/面向对象编程.html" class="sidebar-link">面向对象编程</a></li><li><a href="/Study/ES6/Class.html" aria-current="page" class="active sidebar-link">Class</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Study/ES6/Class.html#参考资料" class="sidebar-link">参考资料</a></li><li class="sidebar-sub-header"><a href="/Study/ES6/Class.html#class基础使用" class="sidebar-link">Class基础使用</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Study/ES6/Class.html#简介" class="sidebar-link">简介</a></li><li class="sidebar-sub-header"><a href="/Study/ES6/Class.html#constructor-方法" class="sidebar-link">constructor 方法</a></li><li class="sidebar-sub-header"><a href="/Study/ES6/Class.html#类的实例" class="sidebar-link">类的实例</a></li><li class="sidebar-sub-header"><a href="/Study/ES6/Class.html#取值函数-getter-和存值函数-setter" class="sidebar-link">取值函数（getter）和存值函数（setter)</a></li><li class="sidebar-sub-header"><a href="/Study/ES6/Class.html#属性表达式" class="sidebar-link">属性表达式</a></li><li class="sidebar-sub-header"><a href="/Study/ES6/Class.html#class-表达式" class="sidebar-link">Class 表达式</a></li><li class="sidebar-sub-header"><a href="/Study/ES6/Class.html#注意点" class="sidebar-link">注意点</a></li><li class="sidebar-sub-header"><a href="/Study/ES6/Class.html#静态方法" class="sidebar-link">静态方法</a></li><li class="sidebar-sub-header"><a href="/Study/ES6/Class.html#实例属性的新写法" class="sidebar-link">实例属性的新写法</a></li><li class="sidebar-sub-header"><a href="/Study/ES6/Class.html#静态属性" class="sidebar-link">静态属性</a></li><li class="sidebar-sub-header"><a href="/Study/ES6/Class.html#私有方法和私有属性" class="sidebar-link">私有方法和私有属性</a></li><li class="sidebar-sub-header"><a href="/Study/ES6/Class.html#静态块" class="sidebar-link">静态块</a></li><li class="sidebar-sub-header"><a href="/Study/ES6/Class.html#new-target-属性" class="sidebar-link">new.target 属性</a></li></ul></li><li class="sidebar-sub-header"><a href="/Study/ES6/Class.html#class的继承" class="sidebar-link">Class的继承</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Study/ES6/Class.html#简介-2" class="sidebar-link">简介</a></li><li class="sidebar-sub-header"><a href="/Study/ES6/Class.html#object-getprototypeof" class="sidebar-link">Object.getPrototypeOf()</a></li><li class="sidebar-sub-header"><a href="/Study/ES6/Class.html#super-关键字" class="sidebar-link">super 关键字</a></li><li class="sidebar-sub-header"><a href="/Study/ES6/Class.html#类的-prototype-属性和-proto-属性" class="sidebar-link">类的 prototype 属性和_proto_属性</a></li><li class="sidebar-sub-header"><a href="/Study/ES6/Class.html#原生构造函数的继承" class="sidebar-link">原生构造函数的继承</a></li><li class="sidebar-sub-header"><a href="/Study/ES6/Class.html#mixin-模式的实现" class="sidebar-link">Mixin 模式的实现</a></li></ul></li></ul></li><li><a href="/Study/ES6/Promise对象.html" class="sidebar-link">Promise对象</a></li><li><a href="/Study/ES6/Generator函数.html" class="sidebar-link">Generator函数</a></li><li><a href="/Study/ES6/async函数.html" class="sidebar-link">async函数</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Vue</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>React</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>浏览器</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>性能</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>NodeJS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>ReactNative</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>TypeScript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>WeChat</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>算法</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>博客搭建</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>flutter</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Git</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="参考资料"><a href="#参考资料" class="header-anchor">#</a> 参考资料</h2> <p><a href="https://es6.ruanyifeng.com/#docs/class" target="_blank" rel="noopener noreferrer">Class<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="class基础使用"><a href="#class基础使用" class="header-anchor">#</a> Class基础使用</h2> <h3 id="简介"><a href="#简介" class="header-anchor">#</a> 简介</h3> <ul><li>类的数据类型就是函数，类本身就指向构造函数</li> <li>使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致。</li> <li>构造函数的prototype属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面。</li> <li>由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。Object.assign()方法可以很方便地一次向类添加多个方法。</li></ul> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token class-name">Point</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">toValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><ul><li>类的内部所有定义的方法，都是不可枚举的（non-enumerable）。</li></ul> <h3 id="constructor-方法"><a href="#constructor-方法" class="header-anchor">#</a> constructor 方法</h3> <ul><li>constructor()方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor()方法，如果没有显式定义，一个空的constructor()方法会被默认添加。</li> <li>类必须使用new调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。</li></ul> <h3 id="类的实例"><a href="#类的实例" class="header-anchor">#</a> 类的实例</h3> <ul><li>生成类的实例的写法，与 ES5 完全一样，也是使用new命令。</li> <li>与 ES5 一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。</li></ul> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">//定义类</span>
<span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">'('</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">+</span> <span class="token string">', '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">+</span> <span class="token string">')'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> point <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
point<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// (2, 3)</span>
point<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'x'</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
point<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'y'</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
point<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'toString'</span><span class="token punctuation">)</span> <span class="token comment">// false</span>
point<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'toString'</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><ul><li>与 ES5 一样，类的所有实例共享一个原型对象。</li> <li>使用实例的__proto__属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。</li></ul> <h3 id="取值函数-getter-和存值函数-setter"><a href="#取值函数-getter-和存值函数-setter" class="header-anchor">#</a> 取值函数（getter）和存值函数（setter)</h3> <ul><li>与 ES5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</li> <li>存值函数和取值函数是设置在属性的 Descriptor 对象上的</li></ul> <h3 id="属性表达式"><a href="#属性表达式" class="header-anchor">#</a> 属性表达式</h3> <ul><li>类的属性名，可以采用表达式</li></ul> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> methodName <span class="token operator">=</span> <span class="token string">'getArea'</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Square</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">length</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
  <span class="token punctuation">[</span>methodName<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="class-表达式"><a href="#class-表达式" class="header-anchor">#</a> Class 表达式</h3> <ul><li>与函数一样，类也可以使用表达式的形式定义。</li></ul> <h3 id="注意点"><a href="#注意点" class="header-anchor">#</a> 注意点</h3> <ul><li>严格模式:类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。</li> <li>不存在提升:类不存在变量提升（hoist），这一点与 ES5 完全不同</li> <li>name 属性:由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性。name属性总是返回紧跟在class关键字后面的类名。</li> <li>Generator 方法:如果某个方法之前加上星号（*），就表示该方法是一个 Generator 函数。</li> <li>this 的指向:类的方法内部如果含有this，它默认指向类的实例。箭头函数内部的this总是指向定义时所在的对象。</li></ul> <h3 id="静态方法"><a href="#静态方法" class="header-anchor">#</a> 静态方法</h3> <ul><li>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</li> <li>注意，如果静态方法包含this关键字，这个this指的是类，而不是实例。</li> <li>静态方法可以与非静态方法重名。</li> <li>父类的静态方法，可以被子类继承。</li> <li>静态方法也是可以从super对象上调用的。</li></ul> <h3 id="实例属性的新写法"><a href="#实例属性的新写法" class="header-anchor">#</a> 实例属性的新写法</h3> <ul><li>实例属性除了定义在constructor()方法里面的this上面，也可以定义在类的最顶层。</li></ul> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">IncreasingCounter</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">get</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Getting the current value!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_count<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_count<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h3 id="静态属性"><a href="#静态属性" class="header-anchor">#</a> 静态属性</h3> <ul><li>静态属性指的是 Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性</li></ul> <h3 id="私有方法和私有属性"><a href="#私有方法和私有属性" class="header-anchor">#</a> 私有方法和私有属性</h3> <ul><li>现有的解决方案
<ol><li>在命名上加以区别。</li> <li>将私有方法移出类</li> <li>利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值。</li></ol></li> <li>私有属性的提案
<ol><li>为class加了私有属性。方法是在属性名之前，使用#表示。</li> <li>私有属性也可以设置 getter 和 setter 方法。</li></ol></li> <li>in 运算符:try...catch结构可以用来判断是否存在某个私有属性。
<ol><li>V8 引擎改进了in运算符，使它也可以用来判断私有属性。</li> <li>in也可以跟this一起配合使用。</li> <li>注意，判断私有属性时，in只能用在定义该私有属性的类的内部。</li> <li>子类从父类继承的私有属性，也可以使用in运算符来判断。</li></ol></li></ul> <h3 id="静态块"><a href="#静态块" class="header-anchor">#</a> 静态块</h3> <ul><li>ES2022 引入了静态块（static block），允许在类的内部设置一个代码块，在类生成时运行一次，主要作用是对静态属性进行初始化。</li> <li>每个类只能有一个静态块，在静态属性声明后运行。静态块的内部不能有return语句。</li> <li>静态块内部可以使用类名或this，指代当前类。</li> <li>除了静态属性的初始化，静态块还有一个作用，就是将私有属性与类的外部代码分享。</li></ul> <h3 id="new-target-属性"><a href="#new-target-属性" class="header-anchor">#</a> new.target 属性</h3> <ul><li>new是从构造函数生成实例对象的命令。ES6 为new命令引入了一个new.target属性，该属性一般用在构造函数之中，返回new命令作用于的那个构造函数。如果构造函数不是通过new命令或Reflect.construct()调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。</li> <li>Class 内部调用new.target，返回当前 Class。</li> <li>需要注意的是，子类继承父类时，new.target会返回子类。</li> <li>注意，在函数外部，使用new.target会报错。</li></ul> <h2 id="class的继承"><a href="#class的继承" class="header-anchor">#</a> Class的继承</h2> <h3 id="简介-2"><a href="#简介-2" class="header-anchor">#</a> 简介</h3> <ul><li>Class 可以通过extends关键字实现继承</li> <li>子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。</li> <li>ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。</li> <li>如果子类没有定义constructor方法，这个方法会被默认添加</li> <li>在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有super方法才能调用父类实例。</li> <li>父类的静态方法，也会被子类继承。</li> <li></li></ul> <h3 id="object-getprototypeof"><a href="#object-getprototypeof" class="header-anchor">#</a> Object.getPrototypeOf()</h3> <ul><li>Object.getPrototypeOf方法可以用来从子类上获取父类。</li></ul> <h3 id="super-关键字"><a href="#super-关键字" class="header-anchor">#</a> super 关键字</h3> <ul><li>super这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同
<ol><li>第一种情况，super作为函数调用时，代表父类的构造函数。(作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错。)</li> <li>第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。(这里需要注意，由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。如果属性定义在父类的原型对象上，super就可以取到。)</li></ol></li> <li>ES6 规定，在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例。</li> <li>由于this指向子类实例，所以如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性。</li> <li>如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象。</li></ul> <h3 id="类的-prototype-属性和-proto-属性"><a href="#类的-prototype-属性和-proto-属性" class="header-anchor">#</a> 类的 prototype 属性和__proto__属性</h3> <ul><li>大多数浏览器的 ES5 实现之中，每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。Class 作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链。
<ol><li>子类的__proto__属性，表示构造函数的继承，总是指向父类。</li> <li>子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。</li></ol></li></ul> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token constant">B</span><span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token constant">A</span> <span class="token comment">// true</span>
<span class="token class-name">B</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">A</span><span class="token punctuation">.</span>prototype <span class="token comment">// true</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><ul><li>实例的 <strong>proto</strong> 属性 :子类实例的__proto__属性的__proto__属性，指向父类实例的__proto__属性。也就是说，子类的原型的原型，是父类的原型。</li> <li>通过子类实例的__proto__.__proto__属性，可以修改父类实例的行为。</li></ul> <h3 id="原生构造函数的继承"><a href="#原生构造函数的继承" class="header-anchor">#</a> 原生构造函数的继承</h3> <ul><li>原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript 的原生构造函数大致有下面这些。
<ol><li>Boolean()</li> <li>Number()</li> <li>String()</li> <li>Array()</li> <li>Date()</li> <li>Function()</li> <li>RegExp()</li> <li>Error()</li> <li>Object()</li></ol> <ul><li>ES5 是先新建子类的实例对象this，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。</li> <li>ES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承。</li> <li>extends关键字不仅可以用来继承类，还可以用来继承原生的构造函数</li> <li>注意，继承Object的子类，有一个行为差异。</li></ul> <h3 id="mixin-模式的实现"><a href="#mixin-模式的实现" class="header-anchor">#</a> Mixin 模式的实现</h3> <ul><li>Mixin 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口。</li></ul></li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">3/10/2022, 12:29:00 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/Study/ES6/面向对象编程.html" class="prev">
        面向对象编程
      </a></span> <span class="next"><a href="/Study/ES6/Promise对象.html">
        Promise对象
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.6f4b980a.js" defer></script><script src="/assets/js/2.1c181746.js" defer></script><script src="/assets/js/18.09872d34.js" defer></script>
  </body>
</html>
